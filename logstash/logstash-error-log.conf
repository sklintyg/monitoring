### Input used when testing
#input {
#  file {
#    path => "<path-to-project>/monitoring/logstash/logs/webcert-catalina*"
#    type => "webcert-log"
#  }
#  file {
#    path => "<path-to-project>/monitoring/logstash/logs/it-catalina.log"
#    type => "intygstjanst-log"
#  }
#  file {
#    path => "<path-to-project>/monitoring/logstash/logs/mi-catalina.log"
#    type => "minaintyg-log"
#  }
#}
###

filter {
  if [type] == "webcert-log" or [type] == "intygstjanst-log" or [type] == "minaintyg-log" {
    # We assume that a new line is a new log entry except when printing
    # stacktraces. Stacktraces are printed indented to the log entry which make
    # this pattern "\^s" work as it checks if the line starts with a space
    multiline {
      pattern => "^20\d\d-\d\d-\d\d"
      what => "previous"
      negate => true
    }

    # SAML logging will sometimes output the certificate for some reason. This
    # does not play nice with out assumption that a new line is a new log entry
    # (when starting at the beginning)
    if [message] =~ /^20\d\d-\d\d-\d\d/ {
      grok {
        patterns_dir => "$PATTERNS_DIR"
          match => ["message", "%{WEBCERTTIMESTAMP:date} \[%{DATA:thread}\] %{LOG_LVL:loglevel} (%{GREEDYDATA:javaclass} \[%{USER:user} %{SESSION:session}\]|%{GREEDYDATA:javaclass}) - %{GREEDYDATA:msg}"]
      }
      date {
        locale => "en"
          match => ["date", "yyyy-MM-dd HH:mm:ss,SSS"]
          target => "@timestamp"
      }

      ### These two loglevels are quite verbose when SAML-logging is enabled. Maybe
      ###drop these in the future
      if [loglevel] == "DEBUG" {
        drop {}
      }
      ###

    # If it did not start with the timestamp we drop the entry
    } else {
      drop {}
    }
  }
}

### Output section used for testing
#output {
#  if "_grokparsefailure" not in [tags] {
#    stdout { codec => rubydebug }
#    elasticsearch { host => localhost }
#  }
#}
###
